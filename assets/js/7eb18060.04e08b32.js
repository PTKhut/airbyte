"use strict";(self.webpackChunkdocu=self.webpackChunkdocu||[]).push([[4295],{11107:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const i={},o="Data Types in Records",s={unversionedId:"understanding-airbyte/supported-data-types",id:"understanding-airbyte/supported-data-types",title:"Data Types in Records",description:"AirbyteRecords are required to conform to the Airbyte type system. This means that all sources must produce schemas and records within these types, and all destinations must handle records that conform to this type system.",source:"@site/../docs/understanding-airbyte/supported-data-types.md",sourceDirName:"understanding-airbyte",slug:"/understanding-airbyte/supported-data-types",permalink:"/understanding-airbyte/supported-data-types",draft:!1,editUrl:"https://github.com/airbytehq/airbyte/blob/master/docs/../docs/understanding-airbyte/supported-data-types.md",tags:[],version:"current",frontMatter:{},sidebar:"mySidebar",previous:{title:"Namespaces",permalink:"/understanding-airbyte/namespaces"},next:{title:"Json to Avro Conversion for Blob Storage Destinations",permalink:"/understanding-airbyte/json-avro-conversion"}},l={},p=[{value:"The types",id:"the-types",level:2},{value:"Record structure",id:"record-structure",level:3},{value:"Nulls",id:"nulls",level:4},{value:"Unsupported types",id:"unsupported-types",level:4},{value:"Specific types",id:"specific-types",level:3},{value:"Boolean",id:"boolean",level:4},{value:"Dates and timestamps",id:"dates-and-timestamps",level:4},{value:"Numeric values",id:"numeric-values",level:4},{value:"Arrays",id:"arrays",level:4},{value:"Objects",id:"objects",level:4},{value:"Unions",id:"unions",level:4}],d={toc:p},m="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"data-types-in-records"},"Data Types in Records"),(0,r.kt)("p",null,"AirbyteRecords are required to conform to the Airbyte type system. This means that all sources must produce schemas and records within these types, and all destinations must handle records that conform to this type system."),(0,r.kt)("p",null,"Because Airbyte's interfaces are JSON-based, this type system is realized using ",(0,r.kt)("a",{parentName:"p",href:"https://json-schema.org/"},"JSON schemas"),". In order to work around some limitations of JSON schemas, we add an additional ",(0,r.kt)("inlineCode",{parentName:"p"},"airbyte_type")," parameter to define more narrow types."),(0,r.kt)("p",null,"This type system does not constrain values. However, destinations may not fully support all values - for example, Avro-based destinations may reject numeric values outside the standard 64-bit representations, or databases may reject timestamps in the BC era."),(0,r.kt)("h2",{id:"the-types"},"The types"),(0,r.kt)("p",null,"This table summarizes the available types. See the ",(0,r.kt)("a",{parentName:"p",href:"#specific-types"},"Specific Types")," section for explanation of optional parameters."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Airbyte type"),(0,r.kt)("th",{parentName:"tr",align:null},"JSON Schema"),(0,r.kt)("th",{parentName:"tr",align:null},"Examples"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"String"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'{"type": "string"}')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"foo bar"'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Boolean"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'{"type": "boolean"}')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"true")," or ",(0,r.kt)("inlineCode",{parentName:"td"},"false"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Date"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'{"type": "string", "format": "date"}')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"2021-01-23"'),", ",(0,r.kt)("inlineCode",{parentName:"td"},'"2021-01-23 BC"'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Timestamp without timezone"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'{"type": "string", "format": "date-time", "airbyte_type": "timestamp_without_timezone"}')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"2022-11-22T01:23:45"'),", ",(0,r.kt)("inlineCode",{parentName:"td"},'"2022-11-22T01:23:45.123456 BC"'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Timestamp with timezone"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'{"type": "string", "format": "date-time"}'),"; optionally ",(0,r.kt)("inlineCode",{parentName:"td"},'"airbyte_type": "timestamp_with_timezone"')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"2022-11-22T01:23:45.123456+05:00"'),", ",(0,r.kt)("inlineCode",{parentName:"td"},'"2022-11-22T01:23:45Z BC"'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Time without timezone"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'{"type": "string", "format": "time", "airbyte_type": "time_without_timezone"}')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"01:23:45.123456"'),", ",(0,r.kt)("inlineCode",{parentName:"td"},'"01:23:45"'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Time with timezone"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'{"type": "string", "format": "time", "airbyte_type": "time_with_timezone"}')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'"01:23:45.123456+05:00"'),", ",(0,r.kt)("inlineCode",{parentName:"td"},'"01:23:45Z"'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Integer"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'{"type": "integer"}')," or ",(0,r.kt)("inlineCode",{parentName:"td"},'{"type": "number", "airbyte_type": "integer"}')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"42"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Number"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'{"type": "number"}')),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"1234.56"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Array"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'{"type": "array"}'),"; optionally ",(0,r.kt)("inlineCode",{parentName:"td"},"items")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"[1, 2, 3]"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Object"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'{"type": "object"}'),"; optionally ",(0,r.kt)("inlineCode",{parentName:"td"},"properties")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'{"foo": "bar"}'))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Union"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'{"oneOf": [...]}')),(0,r.kt)("td",{parentName:"tr",align:null})))),(0,r.kt)("h3",{id:"record-structure"},"Record structure"),(0,r.kt)("p",null,"As a reminder, sources expose a ",(0,r.kt)("inlineCode",{parentName:"p"},"discover")," command, which returns a list of ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/airbytehq/airbyte/blob/111131a193359027d0081de1290eb4bb846662ef/airbyte-protocol/models/src/main/resources/airbyte_protocol/airbyte_protocol.yaml#L122"},(0,r.kt)("inlineCode",{parentName:"a"},"AirbyteStreams")),", and a ",(0,r.kt)("inlineCode",{parentName:"p"},"read")," method, which emits a series of ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/airbytehq/airbyte/blob/111131a193359027d0081de1290eb4bb846662ef/airbyte-protocol/models/src/main/resources/airbyte_protocol/airbyte_protocol.yaml#L46-L66"},(0,r.kt)("inlineCode",{parentName:"a"},"AirbyteRecordMessages")),". The type system determines what a valid ",(0,r.kt)("inlineCode",{parentName:"p"},"json_schema")," is for an ",(0,r.kt)("inlineCode",{parentName:"p"},"AirbyteStream"),", which in turn dictates what messages ",(0,r.kt)("inlineCode",{parentName:"p"},"read")," is allowed to emit."),(0,r.kt)("p",null,"For example, a source could produce this ",(0,r.kt)("inlineCode",{parentName:"p"},"AirbyteStream")," (remember that the ",(0,r.kt)("inlineCode",{parentName:"p"},"json_schema")," must declare ",(0,r.kt)("inlineCode",{parentName:"p"},'"type": "object"')," at the top level):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "name": "users",\n  "json_schema": {\n    "type": "object",\n    "properties": {\n      "username": {\n        "type": "string"\n      },\n      "age": {\n        "type": "integer"\n      },\n      "appointments": {\n        "type": "array",\n        "items": {\n          "type": "string",\n          "format": "date-time",\n          "airbyte_type": "timestamp_with_timezone"\n        }\n      }\n    }\n  }\n}\n')),(0,r.kt)("p",null,"Along with this ",(0,r.kt)("inlineCode",{parentName:"p"},"AirbyteRecordMessage")," (observe that the ",(0,r.kt)("inlineCode",{parentName:"p"},"data")," field conforms to the ",(0,r.kt)("inlineCode",{parentName:"p"},"json_schema")," from the stream):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "stream": "users",\n  "data": {\n    "username": "someone42",\n    "age": 84,\n    "appointments": ["2021-11-22T01:23:45+00:00", "2022-01-22T14:00:00+00:00"]\n  },\n  "emitted_at": 1623861660\n}\n')),(0,r.kt)("p",null,"The top-level ",(0,r.kt)("inlineCode",{parentName:"p"},"object")," must conform to the type system. This ",(0,r.kt)("a",{parentName:"p",href:"#objects"},"means")," that all of the fields must also conform to the type system."),(0,r.kt)("h4",{id:"nulls"},"Nulls"),(0,r.kt)("p",null,"Many sources cannot guarantee that all fields are present on all records. In these cases, sources should simply not list them as ",(0,r.kt)("inlineCode",{parentName:"p"},"required")," fields. In most cases, sources do not need to list fields as required; by default, all fields are treated as nullable."),(0,r.kt)("h4",{id:"unsupported-types"},"Unsupported types"),(0,r.kt)("p",null,"Destinations must have handling for all types, but they are free to cast types to a convenient representation. For example, let's say a source discovers a stream with this schema:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type": "object",\n  "properties": {\n    "appointments": {\n      "type": "array",\n      "items": {\n        "type": "string",\n        "format": "date-time",\n        "airbyte_type": "timestamp_with_timezone"\n      }\n    }\n  }\n}\n')),(0,r.kt)("p",null,"Along with records which contain data that looks like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"appointments": ["2021-11-22T01:23:45+00:00", "2022-01-22T14:00:00+00:00"]}\n')),(0,r.kt)("p",null,"The user then connects this source to a destination that cannot natively handle ",(0,r.kt)("inlineCode",{parentName:"p"},"array")," fields. The destination connector is free to simply JSON-serialize the array back to a string when pushing data into the end platform. In other words, the destination connector could behave as though the source declared this schema:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type": "object",\n  "properties": {\n    "appointments": {\n      "type": "string"\n    }\n  }\n}\n')),(0,r.kt)("p",null,"And emitted this record:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"appointments": "[\\"2021-11-22T01:23:45+00:00\\", \\"2022-01-22T14:00:00+00:00\\"]"}\n')),(0,r.kt)("p",null,"Of course, destinations are free to choose the most convenient/reasonable representation for any given value. JSON serialization is just one possible strategy. For example, many SQL destinations will fall back to a native JSON type (e.g. Postgres' JSONB type, or Snowflake's VARIANT)."),(0,r.kt)("h3",{id:"specific-types"},"Specific types"),(0,r.kt)("p",null,"These sections explain how each specific type should be used."),(0,r.kt)("h4",{id:"boolean"},"Boolean"),(0,r.kt)("p",null,"Boolean values are represented as native JSON booleans (i.e. ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),', case-sensitive). Note that "truthy" and "falsy" values are ',(0,r.kt)("em",{parentName:"p"},"not")," acceptable: ",(0,r.kt)("inlineCode",{parentName:"p"},'"true"'),", ",(0,r.kt)("inlineCode",{parentName:"p"},'"false"'),", ",(0,r.kt)("inlineCode",{parentName:"p"},"1"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," are not valid booleans."),(0,r.kt)("h4",{id:"dates-and-timestamps"},"Dates and timestamps"),(0,r.kt)("p",null,"Airbyte has five temporal types: ",(0,r.kt)("inlineCode",{parentName:"p"},"date"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"timestamp_with_timezone"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"timestamp_without_timezone"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"time_with_timezone"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"time_without_timezone"),". These are represented as strings with specific ",(0,r.kt)("inlineCode",{parentName:"p"},"format")," (either ",(0,r.kt)("inlineCode",{parentName:"p"},"date")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"date-time"),")."),(0,r.kt)("p",null,"However, JSON schema does not have a built-in way to indicate whether a field includes timezone information. For example, given this JsonSchema:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "type": "object",\n  "properties": {\n    "created_at": {\n      "type": "string",\n      "format": "date-time"\n    }\n  }\n}\n')),(0,r.kt)("p",null,"Both ",(0,r.kt)("inlineCode",{parentName:"p"},'{"created_at": "2021-11-22T01:23:45+00:00"}')," and ",(0,r.kt)("inlineCode",{parentName:"p"},'{"created_at": "2021-11-22T01:23:45"}')," are valid records."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"airbyte_type")," field resolves this ambiguity; sources producing timestamp-ish fields should choose either ",(0,r.kt)("inlineCode",{parentName:"p"},"timestamp_with_timezone")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"timestamp_without_timezone")," (or time with/without timezone)."),(0,r.kt)("p",null,"Many sources (which were written before this system was formalized) do not specify the timezone-ness of their fields. Destinations should default to using the ",(0,r.kt)("inlineCode",{parentName:"p"},"with_timezone")," variant in these cases."),(0,r.kt)("p",null,"All of these must be represented as RFC 3339\xa75.6 strings, extended with BC era support. See the type definition descriptions for specifics."),(0,r.kt)("h4",{id:"numeric-values"},"Numeric values"),(0,r.kt)("p",null,"The number and integer types can accept any value, without constraint on range. However, this is still subject to compatibility with the destination: the destination (or normalization) ",(0,r.kt)("em",{parentName:"p"},"may")," throw an error if it attempts to write a value outside the range supported by the destination warehouse / storage medium."),(0,r.kt)("p",null,"Airbyte does not currently support infinity/NaN values."),(0,r.kt)("h4",{id:"arrays"},"Arrays"),(0,r.kt)("p",null,"Arrays contain 0 or more items, which must have a defined type. These types should also conform to the type system. Arrays may require that all of their elements be the same type (",(0,r.kt)("inlineCode",{parentName:"p"},'"items": {whatever type...}'),"). They may instead require each element to conform to one of a list of types (",(0,r.kt)("inlineCode",{parentName:"p"},'"items": [{first type...}, {second type...}, ... , {Nth type...}]'),")."),(0,r.kt)("p",null,"Note that Airbyte's usage of the ",(0,r.kt)("inlineCode",{parentName:"p"},"items")," field is slightly different than JSON schema's usage, in which an ",(0,r.kt)("inlineCode",{parentName:"p"},'"items": [...]')," actually constrains the element correpsonding to the index of that item (AKA tuple-typing). This is becase destinations may have a difficult time supporting tuple-typed arrays without very specific handling, and as such are permitted to somewhat loosen their requirements."),(0,r.kt)("h4",{id:"objects"},"Objects"),(0,r.kt)("p",null,"As with arrays, objects may declare ",(0,r.kt)("inlineCode",{parentName:"p"},"properties"),", each of which should have a type which conforms to the type system."),(0,r.kt)("h4",{id:"unions"},"Unions"),(0,r.kt)("p",null,"Sources may want to mix different types in a single field, e.g. ",(0,r.kt)("inlineCode",{parentName:"p"},'"type": ["string", "object"]'),". Destinations must handle this case, either using a native union type, or by finding a native type that can accept all of the source's types (this frequently will be ",(0,r.kt)("inlineCode",{parentName:"p"},"string")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"json"),")."),(0,r.kt)("p",null,"In some cases, sources may want to use multiple types for the same field. For example, a user might have a property which holds one of two object schemas. This is supported with JSON schema's  ",(0,r.kt)("inlineCode",{parentName:"p"},"oneOf")," type. Note that many destinations do not currently support these types, and may not behave as expected."))}u.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>y});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=p(n),c=r,y=m["".concat(l,".").concat(c)]||m[c]||u[c]||i;return n?a.createElement(y,o(o({ref:t},d),{},{components:n})):a.createElement(y,o({ref:t},d))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"}}]);